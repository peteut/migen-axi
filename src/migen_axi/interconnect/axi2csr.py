from operator import attrgetter
from migen import *  # noqa
from . import axi
from misoc.interconnect import csr_bus

__all__ = ["AXI2CSR"]


class AXI2CSR(Module):
    def __init__(self, bus_axi=None, bus_csr=None):
        self.bus = bus_axi or axi.Interface()
        self.csr = bus_csr or csr_bus.Interface()

        self._max_addr = 2 ** len(self.bus.aw.addr) - 1

        # slave list to add to address decoder at the end
        # csr bus is the first slave
        self.slaves = [(lambda a: a[len(self.csr.adr):] == 0, self.csr)]
        self._relative_addr = 4 * 2 ** len(self.csr.adr)

        ###

        dw = len(self.csr.dat_w)

        if dw not in (8, 16, 32):
            raise NotImplementedError(
                "AXI2CSR data_width shall be in (8, 16, 32)")

    def _add_slave(self, fun, slave):
        # fun - function that takes the adr signal and returns a FHDL expr.
        #       that evaluates to 1 when the slave is selected and 0 otherwise.
        # slave - Memory.port or csr bus reference.
        self.slaves += [(fun, slave)]

    def register_port(self, port, size):
        # for autogenerated function only sizes that are powers of 2
        # can work reliably. round up if this isn't the case.
        # this only changes the size in the address space.
        size = 2 ** (log2_int(size, need_pow2=False))

        self.specials += port

        # check if the remaining part of the address bus
        # corresponds to the possible address
        cut_addr = self._relative_addr >> 2
        addr_bits = log2_int(size >> 2)

        self._add_slave(lambda a: a[addr_bits:] == cut_addr >> addr_bits,
                        port)

        addr_start = self._relative_addr
        self._relative_addr += size

        return addr_start

    def add_memory(self, memory_or_size, read_only=False, init=None):
        data_bus_width = len(self.bus.r.data)

        if isinstance(memory_or_size, Memory):
            memory = memory_or_size
            size = memory.depth * memory.width // 8
        else:
            memory = Memory(data_bus_width,
                            memory_or_size // (data_bus_width // 8),
                            init=init
                            )
            size = memory_or_size

        assert memory.width <= data_bus_width
        assert self._relative_addr + memory.depth <= self._max_addr

        port = memory.get_port(write_capable=not read_only,
                               we_granularity=0)  # csr bus limitation

        self.specials += memory

        addr_start = self.register_port(port, size)

        return addr_start, size

    def do_finalize(self):
        # internal bus that will connect to address decoder
        # needs to be wider than CSR bus to accommodate both bus and any SRAM
        # data width also identical to AXI to accomodate SRAM
        internal_adr_bus_width = log2_int(self._relative_addr, need_pow2=False)

        internal_csr = csr_bus.Interface(
            data_width=len(self.bus.r.data),
            address_width=internal_adr_bus_width)

        ###

        ar, aw, w, r, b = attrgetter("ar", "aw", "w", "r", "b")(self.bus)

        id_ = Signal(len(ar.id), reset_less=True)

        # control
        pending = Signal(reset_less=True)
        self.submodules.fsm = fsm = FSM(reset_state="IDLE")
        fsm.act(
            "IDLE",
            aw.ready.eq(1),
            ar.ready.eq(1),
            If(
                aw.valid,
                ar.ready.eq(0),
                NextValue(internal_csr.adr, aw.addr[2:]),
                NextValue(id_, aw.id),
                NextState("WRITE"),
            ).Elif(
                ar.valid,
                NextValue(internal_csr.adr, ar.addr[2:]),
                NextValue(id_, ar.id),
                NextValue(pending, 1),
                NextState("READ"),
            ),
        )
        fsm.act(
            "WRITE",
            If(
                w.valid,
                w.ready.eq(1),
                NextValue(internal_csr.we, 1),
                NextState("WRITE_DONE"),
            ),
        )
        fsm.act(
            "WRITE_DONE",
            b.valid.eq(1),
            If(
                b.ready,
                NextState("IDLE")
            )
        )
        fsm.act(
            "READ",
            If(
                ~pending,
                NextState("READ_DONE"),
            )
        )
        fsm.act(
            "READ_DONE",
            r.valid.eq(1),
            If(
                r.ready,
                NextState("IDLE"),
            )
        )

        # data path
        self.comb += [
            r.id.eq(id_),
            b.id.eq(id_),
            r.resp.eq(axi.Response.okay),
            b.resp.eq(axi.Response.okay),
            r.last.eq(1),
        ]
        self.sync += [
            pending.eq(0),
            r.data.eq(internal_csr.dat_r),
            internal_csr.we.eq(0),
            internal_csr.dat_w.eq(w.data),
        ]

        decoder = AddressDecoder(internal_csr,
                                 self.slaves,
                                 register=True
                                 )

        self.submodules += [decoder]


class AddressDecoder(Module):
    # slaves is a list of pairs:
    # 0) function that takes the address signal and returns a FHDL expression
    #    that evaluates to 1 when the slave is selected and 0 otherwise.
    # 1) Memory.port or csr bus reference.
    # register adds flip-flops after the address comparators. Improves timing,
    # but breaks Wishbone combinatorial feedback.
    def __init__(self, master, slaves, register=True):
        ns = len(slaves)
        slave_sel = Signal(ns)
        self.slave_sel_r = Signal(ns)

        ###

        # decode slave addresses
        self.comb += [slave_sel[i].eq(fn(master.adr))
                      for i, (fn, _) in enumerate(slaves)]
        if register:
            self.sync += self.slave_sel_r.eq(slave_sel)
        else:
            self.comb += self.slave_sel_r.eq(slave_sel)

        # connect master->slaves signals except we
        for i, slave in enumerate(slaves):
            self.comb += slave[1].adr.eq(master.adr)
            # could be read only, check for that
            if slave[1].dat_w is not None and slave[1].we is not None:
                self.comb += slave[1].dat_w.eq(master.dat_w)
                self.comb += slave[1].we.eq(master.we & self.slave_sel_r[i])

        # mux (1-hot) slave data return
        masked = [Replicate(self.slave_sel_r[i],
                            len(master.dat_r)
                            ) & slaves[i][1].dat_r
                  for i in range(ns)]
        self.comb += master.dat_r.eq(reduce(or_, masked))
